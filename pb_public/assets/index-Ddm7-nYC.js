import{H as C}from"./index-DhUzF4e6.js";var X=Object.defineProperty,$=Object.getOwnPropertySymbols,_=Object.prototype.hasOwnProperty,Z=Object.prototype.propertyIsEnumerable,F=(e,t,n)=>t in e?X(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,j=(e,t)=>{for(var n in t||(t={}))_.call(t,n)&&F(e,n,t[n]);if($)for(var n of $(t))Z.call(t,n)&&F(e,n,t[n]);return e},D=(e,t,n)=>new Promise((s,l)=>{var h=d=>{try{a(n.next(d))}catch(i){l(i)}},m=d=>{try{a(n.throw(d))}catch(i){l(i)}},a=d=>d.done?s(d.value):Promise.resolve(d.value).then(h,m);a((n=n.apply(e,t)).next())});function O(e){return!!e.shadowRoot}let I=!1;function ee(){if(I)return;class e extends HTMLElement{constructor(){super(),this.attachShadow({mode:"open"})}}customElements.define("vue-to-print-shadow-dom",e),I=!0}const te=`
  class VueToPrintShadowDom extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: 'open' });
    }
  }
  customElements.define('vue-to-print-shadow-dom', VueToPrintShadowDom);
`;function ne(e){const t=e.createElement("script");t.setAttribute("type","text/javascript"),t.setAttribute("vue-to-print-custom-script","registry-shadow-dom"),t.innerHTML=te,e.body.appendChild(t)}const oe=`
  function retrieveStyleSheets(styleSheetMap) {
    styleSheetMap.forEach((styleSheetStrings, tagName) => {
      const styleSheets = [];
      for (let i = styleSheetStrings.length; i--;) {
        const styleSheet = new CSSStyleSheet();
        styleSheet.replaceSync(styleSheetStrings[i]);
        styleSheets.push(styleSheet);
      }

      const elements = document.querySelectorAll('vue-to-print-shadow-dom[original-tag-name=' + tagName + ']');
      for (let i = elements.length; i--;) {
        const element = elements[i];
        element.shadowRoot.adoptedStyleSheets = styleSheets;
      }
    });
  }
`;function re(e){const t=e.createElement("script");t.setAttribute("type","text/javascript"),t.setAttribute("vue-to-print-custom-script","registry-retrieve-style-sheets-func"),t.innerHTML=oe,e.body.appendChild(t)}const M=new Map;function B(e){ee();const t=e.nodeName.toLowerCase(),n=e.shadowRoot.adoptedStyleSheets,s=document.createElement("vue-to-print-shadow-dom");s.setAttribute("original-tag-name",t),M.has(t)||M.set(t,new Set);const l=M.get(t);for(let a=n.length;a--;)l.add(n[a]);const h=s.attributes,m=e.attributes;for(let a=m.length;a--;)h.setNamedItem(m[a].cloneNode());return s}function se(){const e=new Map,t=new Map,n=Array.from(M.keys());for(let s=n.length;s--;){const l=[],h=n[s],m=Array.from(M.get(h));for(let a=m.length;a--;){const d=m[a];if(!t.has(d)){let i="";const o=Array.from(d.cssRules);for(let r=o.length;r--;)i+=o[r].cssText;t.set(d,i)}l.push(t.get(d))}e.set(h,l)}return e}function ie(e){const t=e.contentWindow||null;if(!t)throw new Error("Cannot access print window");const n=t.document;if(!n)throw new Error("Cannot access print document");ne(n),re(n);const s=se();t.retrieveStyleSheets(s)}function V(e){return!!customElements.get(e.nodeName.toLowerCase())}let q=!1;function le(){if(q)return;class e extends HTMLElement{constructor(){super()}}customElements.define("vue-to-print-custom-element",e),q=!0}function Y(e){le();const t=e.nodeName.toLowerCase(),n=document.createElement("vue-to-print-custom-element");n.setAttribute("original-tag-name",t);const s=n.attributes,l=e.attributes;for(let h=l.length;h--;)s.setNamedItem(l[h].cloneNode());return n}function U(e){return D(this,null,function*(){e.getAttribute("src")&&(e.complete||(yield new Promise((t,n)=>{e.addEventListener("load",t,{once:!0}),e.addEventListener("error",s=>n(s.error),{once:!0})})))})}function ce(e){return D(this,null,function*(){e.readyState>=2||(yield new Promise((t,n)=>{e.addEventListener("loadeddata",t,{once:!0}),e.addEventListener("error",s=>n(s.error),{once:!0}),e.addEventListener("stalled",()=>n(new Error("Loading video stalled, skipping")),{once:!0})}))})}function ae(e){const t=e.cloneNode(),n=t.getContext("2d");return n&&n.drawImage(e,0,0),t}function de(e,t){const n=e.cloneNode();return t.push(U(n)),n}function ue(e,t){const n=e.cloneNode();n.preload="auto";const s=n.getAttribute("poster");if(s){const l=new Image;l.src=s,t.push(U(l))}else t.push(ce(n));return n}function he(e){const t=e.cloneNode();switch(e.type){case"checkbox":case"radio":t.checked=e.checked;break;default:t.value=e.value;break}return t}function pe(e){const t=e.cloneNode();return t.value=e.value,t}function me(e){const t=e.cloneNode();return t.selected=e.selected,t}const G=new Map([["canvas",ae],["img",de],["video",ue],["input",he],["select",pe],["option",me]]);function fe(e){return e.cloneNode()}function ge(e,t=[]){const n=e.nodeName.toLowerCase();return(G.has(n)?G.get(n):fe)(e,t)}function ye(e){var t;if(e.nodeName.toLowerCase()==="slot"){const n=e.assignedNodes();return n.length>0?n:Array.from(e.childNodes)}else return Array.from(((t=e.shadowRoot)!=null?t:e).childNodes)}function be(e){return D(this,null,function*(){const t=new Map,n=[];let s;O(e)?s=B(e):V(e)?s=Y(e):s=e.cloneNode(),t.set(e,s);const l=[e];for(;l.length;){const h=l.shift(),m=ye(h);if(m.length<=0)continue;const a=t.get(h),d=O(a)?a.shadowRoot:a;for(let i=0;i<m.length;i++){const o=m[i];let r;O(o)?r=B(o):V(o)?r=Y(o):r=ge(o,n),t.set(o,r),l.push(o),d.appendChild(r)}}return yield Promise.all(n),s})}const we={copyStyles:!0,pageStyle:`
        @page {
            /* Remove browser default header (title) and footer (url) */
            margin: 0;
        }
        @media print {
            body {
                /* Tell browsers to print background colors */
                -webkit-print-color-adjust: exact; /* Chrome/Safari/Edge/Opera */
                color-adjust: exact; /* Firefox */
            }
        }
    `,removeAfterPrint:!1,suppressErrors:!1};function Se(e){e=j(j({},we),e);let t=0,n=[],s=[];const l=o=>{const r=e.onAfterPrint,u=e.onPrintError,p=e.print,w=C(e.documentTitle);setTimeout(()=>{var v,A;if(o.contentWindow)if(o.contentWindow.focus(),p)Promise.resolve(p(o)).then(()=>r==null?void 0:r()).then(()=>d()).catch(c=>{u?u("print",c):i(["An error was thrown by the specified `print` function"])});else{if(o.contentWindow.print){const c=(A=(v=o.contentDocument)==null?void 0:v.title)!=null?A:"",R=o.ownerDocument.title;w&&(o.ownerDocument.title=w,o.contentDocument&&(o.contentDocument.title=w)),o.contentWindow.print(),w&&(o.ownerDocument.title=R,o.contentDocument&&(o.contentDocument.title=c))}else i(["Printing for this browser is not currently possible: the browser does not have a `print` method available for iframes."]);r==null||r(),d()}else i(["Printing failed because the `contentWindow` of the print iframe did not load. This is possibly an error with `vue-to-print`. Please file an issue: https://github.com/gregnb/react-to-print/issues/"])},500)},h=o=>{const r=e.onBeforePrint,u=e.onPrintError;if(r){const p=r();p&&typeof p.then=="function"?p.then(()=>{l(o)}).catch(w=>{u&&u("onBeforePrint",w)}):l(o)}else l(o)},m=()=>{const o=e.onBeforeGetContent,r=e.onPrintError;if(o){const u=o();u&&typeof u.then=="function"?u.then(a).catch(p=>{r&&r("onBeforeGetContent",p)}):a()}else a()},a=()=>D(this,null,function*(){const o=C(e.bodyClass),r=C(e.content),u=C(e.copyStyles),p=C(e.fonts),w=C(e.pageStyle),v=C(e.nonce);let A;if(r instanceof HTMLElement?A=r:r.$el&&(A=r.$el.nodeName==="#text"?r.$el.parentElement:r.$el),A===void 0){i(["To print a functional component ensure it is wrapped with `React.forwardRef`, and ensure the forwarded ref is used. See the README for an example: https://github.com/gregnb/react-to-print#examples"]);return}if(A===null){i(['There is nothing to print because the "content" prop returned "null". Please ensure "content" is renderable before allowing "vue-to-print" to be called.']);return}const c=document.createElement("iframe");c.width=`${document.documentElement.clientWidth}px`,c.height=`${document.documentElement.clientHeight}px`,c.style.position="absolute",c.style.top=`-${document.documentElement.clientHeight+100}px`,c.style.left=`-${document.documentElement.clientWidth+100}px`,c.id="printWindow",c.srcdoc="<!DOCTYPE html>";const R=A;if(!R){i(['"vue-to-print" could not locate the DOM node corresponding with the `content` prop']);return}const z=yield be(R),J=document.querySelectorAll("link[rel~='stylesheet']"),K=p?p.length:0;t=J.length+K,n=[],s=[];const N=(T,P)=>{if(n.includes(T)){i(["Tried to mark a resource that has already been handled",T],"debug");return}P?(i(['"vue-to-print" was unable to load a resource but will continue attempting to print the page',...P]),s.push(T)):n.push(T),n.length+s.length===t&&h(c)};c.onload=()=>D(this,null,function*(){var T,P;c.onload=null;const b=c.contentDocument||((T=c.contentWindow)==null?void 0:T.document);if(b){b.body.appendChild(z),p&&((P=c.contentDocument)!=null&&P.fonts&&typeof FontFace<"u"?p.forEach(f=>{const S=new FontFace(f.family,f.source,{weight:f.weight,style:f.style});c.contentDocument.fonts.add(S),S.loaded.then(()=>{N(S)}).catch(H=>{N(S,["Failed loading the font:",S,"Load error:",H])})}):(p.forEach(f=>N(f)),i(['"vue-to-print" is not able to load custom fonts because the browser does not support the FontFace API but will continue attempting to print the page'])));const W=typeof w=="function"?w():w;if(typeof W!="string")i([`"vue-to-print" expected a "string" from \`pageStyle\` but received "${typeof W}". Styles from \`pageStyle\` will not be applied.`]);else{const f=b.createElement("style");v&&(f.setAttribute("nonce",v),b.head.setAttribute("nonce",v)),f.appendChild(b.createTextNode(W)),b.head.appendChild(f)}if(o&&b.body.classList.add(...o.split(" ")),u){const f=document.querySelectorAll("style, link[rel~='stylesheet']");for(let S=0,H=f.length;S<H;++S){const g=f[S];if(g.tagName.toLowerCase()==="style"){const y=b.createElement(g.tagName),E=g.sheet;if(E){let L="";try{const x=E.cssRules.length;for(let k=0;k<x;++k)typeof E.cssRules[k].cssText=="string"&&(L+=`${E.cssRules[k].cssText}\r
`)}catch{i(["A stylesheet could not be accessed. This is likely due to the stylesheet having cross-origin imports, and many browsers block script access to cross-origin stylesheets. See https://github.com/gregnb/react-to-print/issues/429 for details. You may be able to load the sheet by both marking the stylesheet with the cross `crossorigin` attribute, and setting the `Access-Control-Allow-Origin` header on the server serving the stylesheet. Alternatively, host the stylesheet on your domain to avoid this issue entirely.",g],"warning")}y.setAttribute("id",`vue-to-print-${S}`),v&&y.setAttribute("nonce",v),y.appendChild(b.createTextNode(L)),b.head.appendChild(y)}}else if(g.getAttribute("href"))if(g.hasAttribute("disabled"))i(["`vue-to-print` encountered a <link> tag with a `disabled` attribute and will ignore it. Note that the `disabled` attribute is deprecated, and some browsers ignore it. You should stop using it. https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-disabled. The <link> is:",g],"warning"),N(g);else{const y=b.createElement(g.tagName);for(let E=0,L=g.attributes.length;E<L;++E){const x=g.attributes[E];x&&y.setAttribute(x.nodeName,x.nodeValue||"")}y.onload=()=>N(y),y.onerror=(E,L,x,k,Q)=>N(y,["Failed to load",y,"Error:",Q]),v&&y.setAttribute("nonce",v),b.head.appendChild(y)}else i(["`vue-to-print` encountered a <link> tag with an empty `href` attribute. In addition to being invalid HTML, this can cause problems in many browsers, and so the <link> was not loaded. The <link> is:",g],"warning"),N(g)}}}ie(c),(t===0||!u)&&h(c)}),d(!0),document.body.appendChild(c)}),d=o=>{const{removeAfterPrint:r}=e;if(o||r){const u=document.getElementById("printWindow");u&&document.body.removeChild(u)}},i=(o,r="error")=>{const{suppressErrors:u}=e;u||(r==="error"?console.error(o):r==="warning"?console.warn(o):r==="debug"&&console.debug(o))};return{handlePrint:m}}export{Se as k};
